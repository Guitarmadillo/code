# data file for the Fltk User Interface Designer (fluid)
version 1.0400
header_name {.h}
code_name {.cxx}
decl {\#include <stdlib.h>} {private local
}

decl {\#include <iostream>} {private local
}

decl {\#include <iomanip>} {private local
}

decl {\#include "sqlite3.h"} {public local
}

decl {\#include <boost/format.hpp>} {private local
}

decl {\#include <array>} {private local
}

decl {\#include <FL/Fl_Text_Buffer.H>} {private local
}

decl {\#include <FL/Fl_PNG_Image.H>} {private local
}

decl {\#include <FL/fl_ask.H>} {private local
}

comment {
This application is the first program I've written using fltk and fluid.
So far I dig fltk 1.4 quite a bit. 

The goal of the application is allow the user to get a yearly average rate
of return that takes multiple currency or fixed income positions into account.

The program currently allows the user to input two currency positions, 
a fixed income position, and a 3rd currency position.

currency 1 and 2 can be either positive or negative, currency 3 can 
only be the result of one of the short currencies. 
} {in_source in_header
}

comment {// sqlite objects} {in_source in_header
}

decl {int version_num = 21;} {private local
}

decl {char* err; sqlite3* db; const char* dbPath = "config.db"; sqlite3_stmt* stmt;} {private local
}

Function {load_CB(Fl_Widget*w, void* userdata)} {open
} {
  code {// POPULATE SAVED INPUT VALUES FROM DATABASE 

// open db
sqlite3_open(dbPath, &db);

const char* checkTableExistsQuery = "SELECT name FROM sqlite_master WHERE type='table' AND name='MAINWINDOW_INPUTS';";

if (sqlite3_prepare_v2(db, checkTableExistsQuery, -1, &stmt, nullptr) == SQLITE_OK) 
{
	if (sqlite3_step(stmt) == SQLITE_ROW) 
	{
		/* std::cout << "Table exists!" << std::endl; */

		// FINALIZE before going to next prepared statement 
		int finalize = sqlite3_finalize(stmt);
		if(finalize != SQLITE_OK) 
		{
			std::cout<< finalize << std::endl; 
		}
		/* else */
		/* { */
			/* std::cout << " SQL Statement Finalized..." << std::endl; */
		/* } */

		// prepare statement to obtain values from the DB 
		sqlite3_prepare_v2(db, "SELECT * from MAINWINDOW_INPUTS LIMIT 1", -1, &stmt, 0); 

		while(sqlite3_step(stmt) != SQLITE_DONE) 
		{ 
			const unsigned char* currency1size = sqlite3_column_text(stmt, 1);	
			input_currency1size->value((const char*)currency1size);

			const unsigned char* currency1rate = sqlite3_column_text(stmt, 2);	
			input_currency1rate->value((const char*)currency1rate);

			const unsigned char* currency2size = sqlite3_column_text(stmt, 3);	
			input_currency2size->value((const char*)currency2size);

			const unsigned char* currency2rate = sqlite3_column_text(stmt, 4);	
			input_currency2rate->value((const char*)currency2rate);

			const unsigned char* currency3size = sqlite3_column_text(stmt, 5);	
			input_currency3size->value((const char*)currency3size);

			const unsigned char* currency3rate = sqlite3_column_text(stmt, 6);	
			input_currency3rate->value((const char*)currency3rate);

			const unsigned char* tbillsize = sqlite3_column_text(stmt, 7);	
			input_tbillsize->value((const char*)tbillsize);

			const unsigned char* tbillrate = sqlite3_column_text(stmt, 8);	
			input_tbillrate->value((const char*)tbillrate);

			const unsigned char* currency1proceeds_size = sqlite3_column_text(stmt, 9);	
			input_currency1proceeds->value((const char*)currency1proceeds_size);

			const unsigned char* currency1proceeds_rate = sqlite3_column_text(stmt, 10);	
			input_currency1proceedsrate->value((const char*)currency1proceeds_rate);

			const unsigned char* currency2proceeds_size = sqlite3_column_text(stmt, 11);	
			input_currency2proceeds->value((const char*)currency2proceeds_size);

			const unsigned char* currency2proceeds_rate = sqlite3_column_text(stmt, 12);	
			input_currency2proceedsrate->value((const char*)currency2proceeds_rate);

			const unsigned char* currency3proceeds_size = sqlite3_column_text(stmt, 13);	
			input_currency3proceeds->value((const char*)currency3proceeds_size);

			const unsigned char* currency3proceeds_rate = sqlite3_column_text(stmt, 14);	
			input_currency3proceedsrate->value((const char*)currency3proceeds_rate);

			const unsigned char* tbillproceeds = sqlite3_column_text(stmt, 15);	
			input_tbillproceeds->value((const char*)tbillproceeds);

			const unsigned char* tbillproceeds_rate = sqlite3_column_text(stmt, 16);	
			input_tbillproceedsrate->value((const char*)tbillproceeds_rate);

			const unsigned char* fxrate1 = sqlite3_column_text(stmt, 17);	
			input_fxrate1->value((const char*)fxrate1);

			const unsigned char* fxrate2 = sqlite3_column_text(stmt, 18);	
			input_fxrate2->value((const char*)fxrate2);

			const unsigned char* fxrate3 = sqlite3_column_text(stmt, 19);	
			input_fxrate3->value((const char*)fxrate3);
		}

		// The application must finalize every prepared statement in order to avoid resource leaks.
		// // finalize second statement 
		finalize = sqlite3_finalize(stmt);
		if(finalize != SQLITE_OK) 
		{
			std::cout<< finalize << std::endl; 
		}
		/* else */
		/* { */
			/* std::cout << " SQL Statement Finalized..." << std::endl; */
		/* } */
	} 
	/* else */ 
	/* { */
	/* 	std::cout << "Table does not exist. Gracefully doing nothing..." << std::endl; */
	/* } */

} 
else 
{
	std::cerr << "Error preparing SQL statement" << std::endl;
}

sqlite3_close(db); // close the database} {}
}

Function {save_CB(Fl_Widget*w, void* userdata)} {open
} {
  code {// Set up to read existing sqlite3 database (or create if not exists)
	
// obtain the position size values for 4 positions
/* std::string_view tbillsize = input_tbillsize->value() ; */
/* std::string_view currency1size = input_currency1size->value(); */
/* std::string_view currency2size = input_currency2size->value(); */
/* std::string_view currency3size = input_currency3size->value(); */

// obtain the interest rates for 4 positions
/* std::string_view tbillrate = input_tbillrate->value() ; */
/* std::string_view currency1rate = input_currency1rate->value(); */
/* std::string_view currency2rate = input_currency2rate->value(); */
/* std::string_view currency3rate = input_currency3rate->value(); */

// obtain the position sizes for 4 proceeds positions 
/* std::string_view tbillproceeds_size = input_tbillproceeds->value() ; */
/* std::string currency1proceeds_size = input_currency1proceeds->value(); */
/* std::string_view currency2proceeds_size = input_currency2proceeds->value(); */
/* std::string_view currency3proceeds_size = input_currency3proceeds->value(); */

// obtain the interest rates for 4 proceeds positions
/* std::string_view tbillproceeds_rate = input_tbillproceedsrate->value() ; */
/* std::string_view currency1proceeds_rate = input_currency1proceedsrate->value(); */
/* std::string_view currency2proceeds_rate = input_currency2proceedsrate->value(); */
/* std::string_view currency3proceeds_rate = input_currency3proceedsrate->value(); */

// obtain fx rate change values 
/* std::string_view fxrate1 = input_fxrate1->value() ; */
/* std::string_view fxrate2 = input_fxrate2->value() ; */
/* std::string_view fxrate3 = input_fxrate3->value() ; */

// debug 
/* std::cout << "tbillsize: " << tbillsize << " tbillrate: " << tbillrate << */
/* " 1size: " << currency1size << " 1rate: " << currency1rate << " 2size: " << */ 
/* currency2size << " 2rate: " << currency2rate << " 3size: " */ 
/* << currency3size << " 3rate: " << currency3rate << std::endl; */

/* std::cout << "new fx rate: " << fxrate1 << std::endl; */

// open the database
sqlite3_open(dbPath, &db);

// Create the table 
const char* sql = "CREATE TABLE IF NOT EXISTS MAINWINDOW_INPUTS("
	"ID INTEGER PRIMARY KEY, "
	"CURRENCY1SIZE TEXT, "
	"CURRENCY1RATE TEXT, "
	"CURRENCY2SIZE TEXT, "
	"CURRENCY2RATE TEXT, "
	"CURRENCY3SIZE TEXT, "
	"CURRENCY3RATE TEXT, "
	"TBILLSIZE TEXT, "
	"TBILLRATE TEXT, "
	"CURRENCY1PROCEEDS_SIZE TEXT, "
	"CURRENCY1PROCEEDS_RATE TEXT, "
	"CURRENCY2PROCEEDS_SIZE TEXT, "
	"CURRENCY2PROCEEDS_RATE TEXT, "
	"CURRENCY3PROCEEDS_SIZE TEXT, "
	"CURRENCY3PROCEEDS_RATE TEXT, "
	"TBILLPROCEEDS_SIZE TEXT, "
	"TBILLPROCEEDS_RATE TEXT, "
	"FXRATE1 TEXT, "
	"FXRATE2 TEXT, "
	"FXRATE3 TEXT, "
	"C1_COVERCURRENCY INT, "
	"C2_COVERCURRENCY INT, "
	"C3_COVERCURRENCY INT, "
	"C4_COVERCURRENCY INT);";

int result = sqlite3_exec(db, sql, NULL, 0, &err);
if(result != SQLITE_OK)
{
	/* std::cout << "error creating table: " << err << std::endl; */
	sqlite3_free(err); // need to look into that function
}

// ADD OR REPLACE THE ROW IN OUR TABLE 
const std::string insert_sql = "INSERT OR REPLACE INTO MAINWINDOW_INPUTS ("
	"ID, "
	"CURRENCY1SIZE, "
	"CURRENCY1RATE, "
    "CURRENCY2SIZE, "
    "CURRENCY2RATE, "
    "CURRENCY3SIZE, "
	"CURRENCY3RATE, "
	"TBILLSIZE, "
	"TBILLRATE, "
	"CURRENCY1PROCEEDS_SIZE, "
    "CURRENCY1PROCEEDS_RATE, "
    "CURRENCY2PROCEEDS_SIZE, "
    "CURRENCY2PROCEEDS_RATE, "
    "CURRENCY3PROCEEDS_SIZE, "
    "CURRENCY3PROCEEDS_RATE, "
    "TBILLPROCEEDS_SIZE, "
    "TBILLPROCEEDS_RATE, "
    "FXRATE1, "
    "FXRATE2, "
    "FXRATE3) "
 	" VALUES((SELECT ID FROM MAINWINDOW_INPUTS LIMIT 1),"
	"'"+ std::string(input_currency1size->value()) +"', "
	"'"+ std::string(input_currency1rate->value()) +"', "
	"'"+ std::string(input_currency2size->value()) +"', "
	"'"+ std::string(input_currency2rate->value()) +"', "
	"'"+ std::string(input_currency3size->value()) +"', "
	"'"+ std::string(input_currency3rate->value()) +"', "
	"'"+ std::string(input_tbillsize->value()) +"', "
	"'"+ std::string(input_tbillrate->value()) +"', "
	"'"+ std::string(input_currency1proceeds->value()) +"', "
	"'"+ std::string(input_currency1proceedsrate->value()) +"', "
	"'"+ std::string(input_currency2proceeds->value()) +"', "
	"'"+ std::string(input_currency2proceedsrate->value()) +"', "
	"'"+ std::string(input_currency3proceeds->value()) +"', "
	"'"+ std::string(input_currency3proceedsrate->value()) +"', "
	"'"+ std::string(input_tbillproceeds->value()) +"', "
	"'"+ std::string(input_tbillproceedsrate->value()) +"', "
	"'"+ std::string(input_fxrate1->value()) +"', "
	"'"+ std::string(input_fxrate2->value()) +"', "
	"'"+ std::string(input_fxrate3->value()) +"');"; 

/* std::cout << "sql debug: " << insert_sql << std::endl; */

result = sqlite3_exec(db, insert_sql.c_str(), NULL, 0, &err); 
if(result != SQLITE_OK) 
{ 
	std::cout << "error with insert: " << err << std::endl; 
	sqlite3_free(err); // need to look into that function 
} 
else
{
	/* std::cout << "inserted: " << result << std::endl; */
}
	
sqlite3_close(db); // close the database} {}
}

Function {clear_CB(Fl_Widget*w, void* userdata)} {open
} {
  code {// this callback will reset the items in the input fields and clear what is in the SQLite3 database.
//// POPULATE SAVED INPUT VALUES FROM DATABASE 

// open db
sqlite3_open(dbPath, &db);

const char* checkTableExistsQuery = "SELECT name FROM sqlite_master WHERE type='table' AND name='MAINWINDOW_INPUTS';";

if (sqlite3_prepare_v2(db, checkTableExistsQuery, -1, &stmt, nullptr) == SQLITE_OK) 
{
	if (sqlite3_step(stmt) == SQLITE_ROW) 
	{
		/* std::cout << "Table exists!" << std::endl; */

		// FINALIZE before going to next prepared statement 
		int finalize = sqlite3_finalize(stmt);
		if(finalize != SQLITE_OK) 
		{
			std::cout<< finalize << std::endl; 
		}
		/* else */
		/* { */
			/* std::cout << " SQL Statement Finalized..." << std::endl; */
		/* } */

		// prepare statement to obtain values from the DB 
		sqlite3_prepare_v2(db, "SELECT * from MAINWINDOW_INPUTS LIMIT 1", -1, &stmt, 0); 

		while(sqlite3_step(stmt) != SQLITE_DONE) 
		{ 
			const unsigned char* currency1size = sqlite3_column_text(stmt, 1);	
			input_currency1size->value("");

			const unsigned char* currency1rate = sqlite3_column_text(stmt, 2);	
			input_currency1rate->value("");

			const unsigned char* currency2size = sqlite3_column_text(stmt, 3);	
			input_currency2size->value("");

			const unsigned char* currency2rate = sqlite3_column_text(stmt, 4);	
			input_currency2rate->value("");

			const unsigned char* currency3size = sqlite3_column_text(stmt, 5);	
			input_currency3size->value("");

			const unsigned char* currency3rate = sqlite3_column_text(stmt, 6);	
			input_currency3rate->value("");

			const unsigned char* tbillsize = sqlite3_column_text(stmt, 7);	
			input_tbillsize->value("");

			const unsigned char* tbillrate = sqlite3_column_text(stmt, 8);	
			input_tbillrate->value("");

			const unsigned char* currency1proceeds_size = sqlite3_column_text(stmt, 9);	
			input_currency1proceeds->value("");

			const unsigned char* currency1proceeds_rate = sqlite3_column_text(stmt, 10);	
			input_currency1proceedsrate->value("");

			const unsigned char* currency2proceeds_size = sqlite3_column_text(stmt, 11);	
			input_currency2proceeds->value("");

			const unsigned char* currency2proceeds_rate = sqlite3_column_text(stmt, 12);	
			input_currency2proceedsrate->value("");

			const unsigned char* currency3proceeds_size = sqlite3_column_text(stmt, 13);	
			input_currency3proceeds->value("");

			const unsigned char* currency3proceeds_rate = sqlite3_column_text(stmt, 14);	
			input_currency3proceedsrate->value("");

			const unsigned char* tbillproceeds = sqlite3_column_text(stmt, 15);	
			input_tbillproceeds->value("");

			const unsigned char* tbillproceeds_rate = sqlite3_column_text(stmt, 16);	
			input_tbillproceedsrate->value("");

			const unsigned char* fxrate1 = sqlite3_column_text(stmt, 17);	
			input_fxrate1->value("");

			const unsigned char* fxrate2 = sqlite3_column_text(stmt, 18);	
			input_fxrate2->value("");

			const unsigned char* fxrate3 = sqlite3_column_text(stmt, 19);	
			input_fxrate3->value("");
		}

		// The application must finalize every prepared statement in order to avoid resource leaks.
		// // finalize second statement 
		finalize = sqlite3_finalize(stmt);
		if(finalize != SQLITE_OK) 
		{
			std::cout<< finalize << std::endl; 
		}
		/* else */
		/* { */
			/* std::cout << " SQL Statement Finalized..." << std::endl; */
		/* } */

	} 
	/* else */ 
	/* { */
	/* 	std::cout << "Table does not exist. Gracefully doing nothing..." << std::endl; */
	/* } */
} 
else 
{
	std::cerr << "Error preparing SQL statement" << std::endl;
}

sqlite3_close(db); // close the database} {}
}

Function {invert_CB(Fl_Widget*w, void* userdata)} {open
} {
  code {// Handle the inversion of the FX rate for quick swaps. 

// get the userdata to identify which button was pressed 
std::string_view  which_button = (const char*)userdata;

/* std::cout << "button: " << which_button << std::endl; */
if(which_button == "invert1")
{
	double previous_value = std::strtod(input_fxrate1->value(), nullptr);
	double reverse_rate = 1 / previous_value;

	// Allow five decimal places in the output 
	std::ostringstream ss;
	ss << std::fixed << std::setprecision(5) << std::abs(reverse_rate);

	input_fxrate1->value(ss.str().c_str());

}
else if(which_button == "invert2")
{
	double previous_value = std::strtod(input_fxrate2->value(), nullptr);
	double reverse_rate = 1 / previous_value;

	// Allow five decimal places in the output 
	std::ostringstream ss;
	ss << std::fixed << std::setprecision(5) << std::abs(reverse_rate);

	input_fxrate2->value(ss.str().c_str());

}

else if(which_button == "invert3")
{
	double previous_value = std::strtod(input_fxrate3->value(), nullptr);
	double reverse_rate = 1 / previous_value;

	// Allow five decimal places in the output 
	std::ostringstream ss;
	ss << std::fixed << std::setprecision(5) << std::abs(reverse_rate);

	input_fxrate3->value(ss.str().c_str());
}} {}
}

Function {ResponseWindow_CB(Fl_Widget*w, void* userdata)} {open
} {
  code {// This callback handles the window close button for response window
//
// SAVE the values for which currencies for cost to cover to the db

int C1_covercurrency = C1_currencychoice->value();
int C2_covercurrency = C2_currencychoice->value();
int C3_covercurrency = C3_currencychoice->value();
int C4_covercurrency = C4_currencychoice->value();

// debug 
/* std::cout << C1_covercurrency << " " << C2_covercurrency << " " */ 
/* << C3_covercurrency << " " << C4_covercurrency << std::endl; */

// open the database
sqlite3_open(dbPath, &db);

// ADD OR REPLACE THE ROW IN OUR TABLE 
const std::string update_sql = "UPDATE MAINWINDOW_INPUTS SET "
    "C1_COVERCURRENCY = '" + std::to_string(C1_covercurrency) + "', "
    "C2_COVERCURRENCY = '" + std::to_string(C2_covercurrency) + "', "
    "C3_COVERCURRENCY = '" + std::to_string(C3_covercurrency) + "', "
    "C4_COVERCURRENCY = '" + std::to_string(C4_covercurrency) + "' "
    "WHERE ID = 1;";

int result = sqlite3_exec(db, update_sql.c_str(), NULL, 0, &err); 
if(result != SQLITE_OK) 
{ 
	std::cout << "error with insert: " << err << std::endl; 
	sqlite3_free(err); // need to look into that function 
} 
else
{
	/* std::cout << "inserted: " << result << std::endl; */
}
	
sqlite3_close(db); // close the database
				   
// Kill the widget, safely destroys the widget and all it's contents 
w->~Fl_Widget();} {}
}

Function {Calculate_CB(Fl_Widget*w, void* userdata)} {open return_type {static void}
} {
  Fl_Window response_window {
    label {Currency Spread Calculator  - Results}
    user_data {"results_window"}
    callback ResponseWindow_CB open
    xywh {121 113 448 710} type Double align 80
    code0 {response_window->show();} non_modal visible
  } {
    Fl_Flex {} {open
      xywh {4 21 430 107} type HORIZONTAL fixed_size_tuples {2  0 215  1 215 }
    } {
      Fl_Text_Display c1_output {
        label {Currency 1}
        xywh {4 21 215 107} box OXY_UP_FRAME labelcolor 96 textcolor 32
        code0 {//c1_output->wrap_mode(4,0);}
      }
      Fl_Text_Display c2_output {
        label {Currency 2}
        xywh {219 21 215 107} box OXY_UP_FRAME textcolor 32
        code0 {// c2_output->wrap_mode(4,0);}
      }
    }
    Fl_Flex {} {open
      xywh {6 171 430 107} type HORIZONTAL fixed_size_tuples {2  0 215  1 215 }
    } {
      Fl_Text_Display c3_output {
        label {Currency 3}
        xywh {6 171 215 107} box OXY_UP_FRAME textcolor 32
        code0 {// c3_output->wrap_mode(4,0);}
      }
      Fl_Text_Display tbill_output {
        label {Fixed Income}
        xywh {221 171 215 107} box OXY_UP_FRAME textcolor 32
        code0 {// tbill_output->wrap_mode(4,0);}
      }
    }
    Fl_Text_Display blended_output {
      label {Total Return / Cost to Cover}
      xywh {9 551 363 151} box SHADOW_BOX color 34 selection_color 7 labeltype NO_LABEL textsize 15 textcolor 55
      code0 {blended_output->wrap_mode(4,0);}
    }
    Fl_Box {} {
      label label
      xywh {6 132 427 22} box THIN_UP_FRAME color 40 selection_color 78 labeltype NO_LABEL
    }
    Fl_Box {} {
      label label
      xywh {6 281 427 22} box THIN_UP_FRAME color 40 selection_color 78 labeltype NO_LABEL
    }
    Fl_Choice C1_currencychoice {
      label {Cover using:}
      callback Recalculate_CB open
      xywh {107 132 97 21} box GTK_DOWN_BOX down_box BORDER_BOX labelsize 13 when 1
    } {
      MenuItem {} {
        label {Currency 1}
        xywh {20 20 100 20}
      }
      MenuItem {} {
        label {Currency 2}
        xywh {30 30 100 20}
      }
      MenuItem {} {
        label {Currency 3}
        xywh {40 40 100 20}
      }
    }
    Fl_Choice C2_currencychoice {
      label {Cover using:}
      callback Recalculate_CB open
      xywh {314 131 97 21} box GTK_DOWN_BOX down_box BORDER_BOX labelsize 13 when 1
    } {
      MenuItem {} {
        label {Currency 1}
        xywh {30 30 100 20}
      }
      MenuItem {} {
        label {Currency 2}
        xywh {40 40 100 20}
      }
      MenuItem {} {
        label {Currency 3}
        xywh {50 50 100 20}
      }
    }
    Fl_Choice C3_currencychoice {
      label {Cover using:}
      callback Recalculate_CB open
      xywh {97 281 97 21} box GTK_DOWN_BOX down_box BORDER_BOX labelsize 13 when 1
    } {
      MenuItem {} {
        label {Currency 1}
        xywh {40 40 100 20}
      }
      MenuItem {} {
        label {Currency 2}
        xywh {50 50 100 20}
      }
      MenuItem {} {
        label {Currency 3}
        xywh {60 60 100 20}
      }
    }
    Fl_Choice C4_currencychoice {
      label {Cover using:}
      callback Recalculate_CB open
      xywh {314 281 97 21} box GTK_DOWN_BOX down_box BORDER_BOX labelsize 13 when 1
    } {
      MenuItem {} {
        label {Currency 1}
        xywh {50 50 100 20}
      }
      MenuItem {} {
        label {Currency 2}
        xywh {60 60 100 20}
      }
      MenuItem {} {
        label {Currency 3}
        xywh {70 70 100 20}
      }
    }
    Fl_Flex {} {open
      xywh {6 320 427 105} type HORIZONTAL fixed_size_tuples {2  0 214  1 213 }
    } {
      Fl_Text_Display c1_reinvest_output {
        label {Currency 1 Re-invest}
        xywh {6 320 214 105} box OXY_UP_FRAME labelcolor 96 align 161 textcolor 32
        code0 {// c1_reinvest_output->wrap_mode(4,0);}
      }
      Fl_Text_Display c2_reinvest_output {
        label {Currency 2 Re-invest}
        xywh {220 320 213 105} box OXY_UP_FRAME textcolor 32
        code0 {// c2_reinvest_output->wrap_mode(4,0);}
      }
    }
    Fl_Flex {} {open
      xywh {6 442 427 105} type HORIZONTAL fixed_size_tuples {2  0 214  1 213 }
    } {
      Fl_Text_Display c3_reinvest_output {
        label {Currency 3 Re-invest}
        xywh {6 442 214 105} box OXY_UP_FRAME labelcolor 96 align 161 textcolor 32
        code0 {// c3_reinvest_output->wrap_mode(4,0);}
      }
      Fl_Text_Display tbill_reinvest_output {
        label {Short Bonds Re-invest}
        xywh {220 442 213 105} box OXY_UP_FRAME textcolor 32
        code0 {// tbill_reinvest_output->wrap_mode(4,0);}
      }
    }
    Fl_Button recalc_button {
      label Calculate
      callback Recalculate_CB
      xywh {377 553 67 53} box GTK_THIN_UP_BOX down_box GTK_THIN_DOWN_BOX color 215 selection_color 175
    }
    Fl_Button save_button2 {
      label Save
      callback save_CB
      xywh {376 612 67 40} box GTK_THIN_UP_BOX down_box GTK_THIN_DOWN_BOX color 166 selection_color 166
    }
    Fl_Button close_button {
      label Close
      xywh {377 661 67 40} box GTK_THIN_UP_BOX down_box GTK_THIN_DOWN_BOX color 214 selection_color 214
    }
  }
  code {// Code that will be called when we press the calculate button 
//
//
// Load the values from the DB for currencies to cover 
// open (ALREADY IN ABOVE CODE)
sqlite3_open(dbPath, &db);

const char* checkTableExistsQuery = "SELECT name FROM sqlite_master WHERE type='table' AND name='MAINWINDOW_INPUTS';";

if (sqlite3_prepare_v2(db, checkTableExistsQuery, -1, &stmt, nullptr) == SQLITE_OK) 
{
	if (sqlite3_step(stmt) == SQLITE_ROW) 
	{
		/* std::cout << "Table exists!" << std::endl; */

		// FINALIZE before going to next prepared statement 
		int finalize = sqlite3_finalize(stmt);
		if(finalize != SQLITE_OK) 
		{
			std::cout<< finalize << std::endl; 
		}
		/* else */
		/* { */
			/* std::cout << " SQL Statement Finalized..." << std::endl; */
		/* } */

		// prepare statement to obtain values from the DB 
		sqlite3_prepare_v2(db, "SELECT * from MAINWINDOW_INPUTS LIMIT 1", -1, &stmt, 0); 

		while(sqlite3_step(stmt) != SQLITE_DONE) 
		{ 
			int C1_covercurrency = sqlite3_column_int(stmt, 20);	
			C1_currencychoice->value(C1_covercurrency);

			int C2_covercurrency = sqlite3_column_int(stmt, 21);	
			C2_currencychoice->value(C2_covercurrency);

			int C3_covercurrency = sqlite3_column_int(stmt, 22);	
			C3_currencychoice->value(C3_covercurrency);

			int C4_covercurrency = sqlite3_column_int(stmt, 23);	
			C4_currencychoice->value(C4_covercurrency);
		}

		// The application must finalize every prepared statement in order to avoid resource leaks.
		// // finalize second statement 
		finalize = sqlite3_finalize(stmt);
		if(finalize != SQLITE_OK) 
		{
			std::cout<< finalize << std::endl; 
		}
		/* else */
		/* { */
			/* std::cout << " SQL Statement Finalized..." << std::endl; */
		/* } */
	} 
	/* else */ 
	/* { */
	/* 	std::cout << "Table does not exist. Gracefully doing nothing..." << std::endl; */
	/* } */
} 
else 
{
	std::cerr << "Error preparing SQL statement" << std::endl;
}

sqlite3_close(db); // close the database
//
// Some of the calculations are borrowed from int calculator v1
// The first thing we should do is safely obtain all of the user inputs 
// all amounts are obtained as doubles
//
// const char* myvalue = input_currency1size->value(); Convert the const char*
// to double (this function automatically removes invalid characters from the
// end of the double

// obtain the 4 primary position sizes 
double currency1size = std::strtod(input_currency1size->value(), nullptr);
double currency2size = std::strtod(input_currency2size->value(), nullptr);
double currency3size = std::strtod(input_currency3size->value(), nullptr);
double tbillsize = std::strtod(input_tbillsize->value(), nullptr);

// obtain the 4 primary position interest rates 
double currency1rate = std::strtod(input_currency1rate->value(), nullptr) / 100;
double currency2rate = std::strtod(input_currency2rate->value(), nullptr) / 100;
double currency3rate = std::strtod(input_currency3rate->value(), nullptr) / 100;
double tbillrate = std::strtod(input_tbillrate->value(), nullptr) / 100;

// obtain the 4 proceeds position sizes 
double currency1proceeds = std::strtod(input_currency1proceeds->value(), nullptr);
double currency2proceeds = std::strtod(input_currency2proceeds->value(), nullptr);
double currency3proceeds = std::strtod(input_currency3proceeds->value(), nullptr);
double tbillproceeds = std::strtod(input_tbillproceeds->value(), nullptr);

// obtain the 4 proceeds position interest rates 
double currency1proceeds_rate = std::strtod(input_currency1proceedsrate->value(), nullptr) / 100;
double currency2proceeds_rate = std::strtod(input_currency2proceedsrate->value(), nullptr) / 100;
double currency3proceeds_rate = std::strtod(input_currency3proceedsrate->value(), nullptr) / 100;
double tbillproceeds_rate = std::strtod(input_tbillproceedsrate->value(), nullptr) / 100;

// obtain fx rate change values 
double fxrate1 = std::strtod(input_fxrate1->value(), nullptr);
double fxrate2 = std::strtod(input_fxrate2->value(), nullptr);
double fxrate3 = std::strtod(input_fxrate3->value(), nullptr);

// debug 
/* std::cout << "tbillsize: " << tbillsize << " tbillrate: " << tbillrate << */
/* " 1size: " << currency1size << " 1rate: " << currency1rate << " 2size: " << */ 
/* currency2size << " 2rate: " << currency2rate << " 3size: " */ 
/* << currency3size << " 3rate: " << currency3rate << std::endl; */

// debug 
/* std::cout << "new fx rate: " << fxrate1 << std::endl; */

// variables to use 
double blended_one_year_profit = 0;
double total_currency = 0;
double blended_percent_return = 0;

// items for cost to cover calculation
double c1_cost_to_cover = 0;
double c2_cost_to_cover = 0;
double c3_cost_to_cover = 0;

// used to sum negative balances 
double total_debt = 0;

// fx rate values will be 0 if they have not been set by the user.

// so basically we want to calculate the rate of return for each position 
// and then get the sum of those rate of returns to get the total rate 
if(currency1size != 0)
{
	if(currency1size > 0)
	{
		total_currency += currency1size;
	}

	// solve for the daily int rate 
	double daily_int_rate = currency1rate / 365;

	// one year PL 
	double one_year_profit = (currency1size * currency1rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency1size) * 100;

	// if profit is negative, calculate cost to cover using cover currency input 
	if(one_year_profit < 0)
	{
		// since our profit is negative we have a negative balance so append it to the total debt
		total_debt += currency1size;

		// get selected cover currency from FL_Input
		int cover_currency = C1_currencychoice->value();
		switch (cover_currency) 
		{
		case 0:
			{
			// CASE 0 IS THE CURRENT CURRENCY.
			// No exchange rate possible.

			c1_cost_to_cover = std::abs(currency1size);

			// Formatting will be same as below 
			boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
			"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency1size 
			%final_percent_return %one_year_profit %daily_profit %c1_cost_to_cover;

			std::string c1_result = fmt.str();

			// create buffer and assign it to the appropriate text display widget 
			Fl_Text_Buffer *c1buff = new Fl_Text_Buffer();
			c1_output->buffer(c1buff);

			// add the text to our buffer (to the box)
			c1buff->text(c1_result.c_str());

			// append the values to our total
			blended_one_year_profit += one_year_profit;
			}
			break;
		case 1:
			if(fxrate1 != 0) // they needed to input an exchange rate  
			{
				// cover with currency2 (fxrate1 is between C1 and C2 so we reverse the rate here)
				c1_cost_to_cover = std::abs(currency1size / (1 / fxrate1) ); 

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency1size 
				%final_percent_return %one_year_profit %daily_profit %c1_cost_to_cover;

				// write it to string
				std::string c1_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c1buff = new Fl_Text_Buffer();
				c1_output->buffer(c1buff);

				// add the text to our buffer (to the box)
				c1buff->text(c1_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;

			}
			else
			{
				std::cout << "Error: Currency 1 Cover currency is Currency 2." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		case 2:
			if(fxrate3 != 0) // they needed to input an exchange rate  
			{
				// cover with currency3 (fxrate3 is between C1 and C3)
				c1_cost_to_cover = std::abs(currency1size / (1 / fxrate3) ) ;	

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency1size 
				%final_percent_return %one_year_profit %daily_profit %c1_cost_to_cover;

				// write it to string
				std::string c1_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c1buff = new Fl_Text_Buffer();
				c1_output->buffer(c1buff);

				// add the text to our buffer (to the box)
				c1buff->text(c1_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;
			}
			else
			{
				std::cout << "Error: Currency 1 Cover currency is Currency 3." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		}

	}		
	else // Profit is positive or flat therefore no cost to cover calculation
	{
		boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
		"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency1size %final_percent_return 
		%one_year_profit %daily_profit;

		std::string c1_result = fmt.str();

		/* std::cout << c1_result << std::endl; */

		// This should maybe be global but not sure. It works. 
		// create buffer and assign it to the appropriate text display widget 
		Fl_Text_Buffer *c1buff = new Fl_Text_Buffer();
		c1_output->buffer(c1buff);

		// add the text to our buffer (to the box)
		c1buff->text(c1_result.c_str());

		// append the values to our total
		blended_one_year_profit += one_year_profit;
	}
}

if(currency2size != 0)
{
	if(currency2size > 0)
	{
		total_currency += currency2size;
	}

	/* std::cout << "total currency: " << total_currency << std::endl; */

	// solve for the daily int rate 
	double daily_int_rate = currency2rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (currency2size * currency2rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency2size) * 100;

	// if profit is negative, calculate cost to cover using cover currency input 
	if(one_year_profit < 0)
	{
		// since our profit is negative we have a negative balance so append it to the total debt
		total_debt += currency2size;

		// get selected cover currency from FL_Input
		int cover_currency = C2_currencychoice->value();
		switch (cover_currency) 
		{
		case 0: // Currency1
			if(fxrate1 != 0) // they needed to input an exchange rate  
			{
				// cover with currency1 (fxrate1 is between C1 and C2)
				c2_cost_to_cover = std::abs(currency2size / fxrate1);	

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency2size 
				%final_percent_return %one_year_profit %daily_profit %c2_cost_to_cover;

				// write it to string
				std::string c2_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c2buff = new Fl_Text_Buffer();
				c2_output->buffer(c2buff);

				// add the text to our buffer (to the box)
				c2buff->text(c2_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;

			}
			else
			{
				std::cout << "Error: Currency 2 Cover currency is Currency 1." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		case 1: //Currency2
			{
			// CASE NOT APPLICABLE BECAUSE IT IS THE CURRENT CURRENCY.
			// No exchange rate possible.
			
			c2_cost_to_cover = std::abs(currency2size);

			// Formatting will be same as below 
			boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
			"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency2size %final_percent_return 
			%one_year_profit %daily_profit %c2_cost_to_cover;

			std::string c2_result = fmt.str();

			// create buffer and assign it to the appropriate text display widget 
			Fl_Text_Buffer *c2buff = new Fl_Text_Buffer();
			c2_output->buffer(c2buff);

			// add the text to our buffer (to the box)
			c2buff->text(c2_result.c_str());

			// append the values to our total
			blended_one_year_profit += one_year_profit;
			}
			break;
		case 2:
			if(fxrate2 != 0) // they needed to input an exchange rate  
			{
				// cover with currency3 (fxrate3 is between C2 and C3)
				c2_cost_to_cover = std::abs(currency2size / (1 / fxrate2) );	

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency2size 
				%final_percent_return %one_year_profit %daily_profit %c2_cost_to_cover;

				// write it to string
				std::string c2_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c2buff = new Fl_Text_Buffer();
				c2_output->buffer(c2buff);

				// add the text to our buffer (to the box)
				c2buff->text(c2_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;
			}
			else
			{
				std::cout << "Error: Currency 2 Cover currency is Currency 3." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		}

	}		
	else // Profit is positive or flat therefore no cost to cover calculation
	{
		boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
		"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency2size %final_percent_return 
		%one_year_profit %daily_profit;

		std::string c2_result = fmt.str();

		// create buffer and assign it to the appropriate text display widget 
		Fl_Text_Buffer *c2buff = new Fl_Text_Buffer();

		c2_output->buffer(c2buff);

		// add the text to our buffer (to the box)
		c2buff->text(c2_result.c_str());

		// append the values to our total
		blended_one_year_profit += one_year_profit;
	}

}

if(currency3size != 0)
{
	// only count positive currencies in our total capital 
	if(currency3size > 0)
	{
		total_currency += currency3size;
	}

	// solve for the daily int rate 
	double daily_int_rate = currency3rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (currency3size * currency3rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency3size) * 100;

	// if profit is negative, calculate cost to cover using cover currency input 
	if(one_year_profit < 0)
	{
		// since our profit is negative we have a negative balance so append it to the total debt
		total_debt += currency3size;

		// get selected cover currency from FL_Input
		int cover_currency = C3_currencychoice->value();
		switch (cover_currency) 
		{
		case 0: // Currency1
			if(fxrate3 != 0) // they needed to input an exchange rate  
			{
				// cover with currency1 (fxrate3 is between C1 and C3)
			 	c3_cost_to_cover = std::abs(currency3size / fxrate3);	

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency3size 
				%final_percent_return %one_year_profit %daily_profit %c3_cost_to_cover;

				// write it to string
				std::string c3_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c3buff = new Fl_Text_Buffer();
				c3_output->buffer(c3buff);

				// add the text to our buffer (to the box)
				c3buff->text(c3_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;

			}
			else
			{
				std::cout << "Error: Currency 3 Cover currency is Currency 1." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		case 1: // cover with Currency 2
			if(fxrate2 != 0) // they needed to input an exchange rate  
			{
				// cover with currency2 (fxrate2 is between C2 and C3)
				c3_cost_to_cover = std::abs(currency3size / fxrate2);	

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency3size 
				%final_percent_return %one_year_profit %daily_profit %c3_cost_to_cover;

				// write it to string
				std::string c3_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c3buff = new Fl_Text_Buffer();
				c3_output->buffer(c3buff);

				// add the text to our buffer (to the box)
				c3buff->text(c3_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;
			}
			else
			{
				std::cout << "Error: Currency 3 Cover currency is Currency 2." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		case 2:
			{
			// CASE NOT APPLICABLE BECAUSE IT IS THE CURRENT CURRENCY.
			// No exchange rate possible.
			
			c3_cost_to_cover = std::abs(currency3size);

			boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
			"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency3size %final_percent_return 
			%one_year_profit %daily_profit %c3_cost_to_cover;

			std::string c3_result = fmt.str();

			// create buffer and assign it to the appropriate text display widget 
			Fl_Text_Buffer *c3buff = new Fl_Text_Buffer();
			c3_output->buffer(c3buff);

			// add the text to our buffer (to the box)
			c3buff->text(c3_result.c_str());

			// append the values to our total
			blended_one_year_profit += one_year_profit;
			}
			break;
		}

	}		
	else // Profit is positive or flat therefore no cost to cover calculation
	{
		boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
		"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency3size %final_percent_return 
		%one_year_profit %daily_profit;

		std::string c3_result = fmt.str();

		// create buffer and assign it to the appropriate text display widget 
		Fl_Text_Buffer *c3buff = new Fl_Text_Buffer();

		c3_output->buffer(c3buff);

		// add the text to our buffer (to the box)
		c3buff->text(c3_result.c_str());

		// append the values to our total
		blended_one_year_profit += one_year_profit;
	}
}

if(tbillsize != 0)
{
	// only count positive currencies 
	if(tbillsize > 0)
	{
		total_currency += tbillsize;
	}

	// solve for the daily int rate 
	double daily_int_rate = tbillrate / 365;

	// set a trade fee to subtract 
	double trade_fee = 7.5;

	// calculate one year rate of return 
	double one_year_profit = (tbillsize * tbillrate) - trade_fee;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / tbillsize) * 100;

	boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
	"One Year P/L: $%3%\\nDaily P/L: $%4%") %tbillsize %final_percent_return %one_year_profit %daily_profit;

	std::string tbill_result = fmt.str();

	// create buffer and assign it to the appropriate text display widget 
	Fl_Text_Buffer *tbill_buffer = new Fl_Text_Buffer();
	tbill_output->buffer(tbill_buffer);

	// add the text to our buffer (to the box)
	tbill_buffer->text(tbill_result.c_str());

	// append the values to our total
	blended_one_year_profit += one_year_profit;
}

// PROCEEDS TEXT OUTPUT
if(currency1proceeds != 0)
{
	// append amount to total currency since we are in possession of the short
	// position proceeds
	total_currency += currency1proceeds;
	
	// solve for the daily int rate 
	double daily_int_rate = currency1proceeds_rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (currency1proceeds * currency1proceeds_rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency1proceeds) * 100;

	boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
	"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency1proceeds %final_percent_return %one_year_profit %daily_profit;

	std::string result = fmt.str();

	// create buffer and assign it to the appropriate text display widget 
	Fl_Text_Buffer *c1_buffer = new Fl_Text_Buffer();
	c1_reinvest_output->buffer(c1_buffer);

	// add the text to our buffer (to the box)
	c1_buffer->text(result.c_str());

	// append the values to our total
	blended_one_year_profit += one_year_profit;
	blended_one_year_profit += one_year_profit;
	std::cout << "1 one year profit: " << one_year_profit << std::endl;
	std::cout << "1 blended one year profit: " << blended_one_year_profit << std::endl;
}

if(currency2proceeds != 0)
{
	// append amount to total currency since we are in possession of the short
	// position proceeds
	total_currency += currency2proceeds;

	// solve for the daily int rate 
	double daily_int_rate = currency2proceeds_rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (currency2proceeds * currency2proceeds_rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency2proceeds) * 100;

	boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
	"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency2proceeds %final_percent_return %one_year_profit %daily_profit;

	std::string result = fmt.str();

	// create buffer and assign it to the appropriate text display widget 
	Fl_Text_Buffer *c2_buffer = new Fl_Text_Buffer();
	c2_reinvest_output->buffer(c2_buffer);

	// add the text to our buffer (to the box)
	c2_buffer->text(result.c_str());

	// append the values to our total
	blended_one_year_profit += one_year_profit;
	std::cout << "2 one year profit: " << one_year_profit << std::endl;
	std::cout << "2 blended one year profit: " << blended_one_year_profit << std::endl;
}

if(currency3proceeds != 0)
{
	// append amount to total currency since we are in possession of the short
	// position proceeds
	total_currency += currency3proceeds;

	// solve for the daily int rate 
	double daily_int_rate = currency3proceeds_rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (currency3proceeds * currency3proceeds_rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency3proceeds) * 100;

	boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
	"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency3proceeds %final_percent_return %one_year_profit %daily_profit;

	std::string result = fmt.str();

	// create buffer and assign it to the appropriate text display widget 
	Fl_Text_Buffer *c3_buffer = new Fl_Text_Buffer();
	c3_reinvest_output->buffer(c3_buffer);

	// add the text to our buffer (to the box)
	c3_buffer->text(result.c_str());

	// append the values to our total
	blended_one_year_profit += one_year_profit;
	std::cout << "3 one year profit: " << one_year_profit << std::endl;
	std::cout << "3 blended one year profit: " << blended_one_year_profit << std::endl;
}
if(tbillproceeds != 0)
{
	// Proceeds will always be positive
	
	// append amount to total currency since we are in possession of the short
	// position proceeds
	total_currency += tbillproceeds;

	// solve for the daily int rate 
	double daily_int_rate = tbillproceeds_rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (tbillproceeds * tbillproceeds_rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / tbillproceeds) * 100;

	boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
	"One Year P/L: $%3%\\nDaily P/L: $%4%") %tbillproceeds %final_percent_return %one_year_profit %daily_profit;

	std::string result = fmt.str();

	// create buffer and assign it to the appropriate text display widget 
	Fl_Text_Buffer *tbill_buffer = new Fl_Text_Buffer();
	tbill_reinvest_output->buffer(tbill_buffer);

	// add the text to our buffer (to the box)
	tbill_buffer->text(result.c_str());

	// append the values to our total
	blended_one_year_profit += one_year_profit;
	std::cout << "4 one year profit: " << one_year_profit << std::endl;
	std::cout << "4 blended one year profit: " << blended_one_year_profit << std::endl;
}

// LOGIC FOR TOTALS CALCULATIONS 

// solve for blended percent return 
blended_percent_return = (blended_one_year_profit / total_currency) * 100;

// used for solving cost to cover if applicable 
double cost_to_cover = 0;

// used for formatting text to pass into buffer 
std::string result; 

// if any of these currencies are negative we need to format text with cost to cover
if(currency1size < 0 || currency2size < 0 || currency3size < 0)
{
	// simply add up all cost to covers and we will get a total
	double total_cost_to_cover = c1_cost_to_cover + c2_cost_to_cover + c3_cost_to_cover;

	boost::format fmt = boost::format("Total Capital: $%1%\\nTotal Debt: $%2%\\n"
	"Blended Interest Rate: %3%%%\\nOne Year P/L: $%4%\\n"
	"Cost to Cover with FX rate: $%5%") %total_currency %total_debt %blended_percent_return 
	%blended_one_year_profit % total_cost_to_cover ;

	// write to the string
	result = fmt.str();
}
else
{
	// no currencies are negative therefore format without cost to cover 

	boost::format fmt = boost::format("Total Capital: $%1%\\n"
	"Blended Interest Rate: %2%%%\\nOne Year P/L: $%3%\\n") %total_currency 
	%blended_percent_return %blended_one_year_profit ;

	// write to the string
	result = fmt.str();
}

// debug 
/* std::cout << "Total One Year Profit/Loss was: " << blended_one_year_profit */ 
/* << std::endl; */
/* std::cout << "Total return: " << blended_percent_return */ 
/* << "%" << std::endl; */

// create a new buffer 
Fl_Text_Buffer *total_buffer = new Fl_Text_Buffer();

// assign the buffer to a text display widget
blended_output->buffer(total_buffer);

// add the text to our buffer 
total_buffer->text(result.c_str());} {}
}

Function {Recalculate_CB(Fl_Widget*w, void* userdata)} {open
} {
  code {// Code that will be called when we press the calculate button 
//
// Some of the calculations are borrowed from int calculator v1
// The first thing we should do is safely obtain all of the user inputs 
// all amounts are obtained as doubles
//
// const char* myvalue = input_currency1size->value(); Convert the const char*
// to double (this function automatically removes invalid characters from the
// end of the double

// obtain the 4 primary position sizes 
double currency1size = std::strtod(input_currency1size->value(), nullptr);
double currency2size = std::strtod(input_currency2size->value(), nullptr);
double currency3size = std::strtod(input_currency3size->value(), nullptr);
double tbillsize = std::strtod(input_tbillsize->value(), nullptr);

// obtain the 4 primary position interest rates 
double currency1rate = std::strtod(input_currency1rate->value(), nullptr) / 100;
double currency2rate = std::strtod(input_currency2rate->value(), nullptr) / 100;
double currency3rate = std::strtod(input_currency3rate->value(), nullptr) / 100;
double tbillrate = std::strtod(input_tbillrate->value(), nullptr) / 100;

// obtain the 4 proceeds position sizes 
double currency1proceeds = std::strtod(input_currency1proceeds->value(), nullptr);
double currency2proceeds = std::strtod(input_currency2proceeds->value(), nullptr);
double currency3proceeds = std::strtod(input_currency3proceeds->value(), nullptr);
double tbillproceeds = std::strtod(input_tbillproceeds->value(), nullptr);

// obtain the 4 proceeds position interest rates 
double currency1proceeds_rate = std::strtod(input_currency1proceedsrate->value(), nullptr) / 100;
double currency2proceeds_rate = std::strtod(input_currency2proceedsrate->value(), nullptr) / 100;
double currency3proceeds_rate = std::strtod(input_currency3proceedsrate->value(), nullptr) / 100;
double tbillproceeds_rate = std::strtod(input_tbillproceedsrate->value(), nullptr) / 100;

// obtain fx rate change values 
double fxrate1 = std::strtod(input_fxrate1->value(), nullptr);
double fxrate2 = std::strtod(input_fxrate2->value(), nullptr);
double fxrate3 = std::strtod(input_fxrate3->value(), nullptr);

// debug 
/* std::cout << "tbillsize: " << tbillsize << " tbillrate: " << tbillrate << */
/* " 1size: " << currency1size << " 1rate: " << currency1rate << " 2size: " << */ 
/* currency2size << " 2rate: " << currency2rate << " 3size: " */ 
/* << currency3size << " 3rate: " << currency3rate << std::endl; */

// debug 
/* std::cout << "new fx rate: " << fxrate1 << std::endl; */

// variables to use 
double blended_one_year_profit = 0;
double total_currency = 0;
double blended_percent_return = 0;

// items for cost to cover calculation
double c1_cost_to_cover = 0;
double c2_cost_to_cover = 0;
double c3_cost_to_cover = 0;

// used to sum negative balances 
double total_debt = 0;

// fx rate values will be 0 if they have not been set by the user.

// so basically we want to calculate the rate of return for each position 
// and then get the sum of those rate of returns to get the total rate 
if(currency1size != 0)
{
	if(currency1size > 0)
	{
		total_currency += currency1size;
	}

	// solve for the daily int rate 
	double daily_int_rate = currency1rate / 365;

	// one year PL 
	double one_year_profit = (currency1size * currency1rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency1size) * 100;

	// if profit is negative, calculate cost to cover using cover currency input 
	if(one_year_profit < 0)
	{
		// since our profit is negative we have a negative balance so append it to the total debt
		total_debt += currency1size;

		// get selected cover currency from FL_Input
		int cover_currency = C1_currencychoice->value();
		switch (cover_currency) 
		{
		case 0:
			{
			// CASE 0 IS THE CURRENT CURRENCY.
			// No exchange rate possible.

			c1_cost_to_cover = std::abs(currency1size);

			// Formatting will be same as below 
			boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
			"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency1size 
			%final_percent_return %one_year_profit %daily_profit %c1_cost_to_cover;

			std::string c1_result = fmt.str();

			// create buffer and assign it to the appropriate text display widget 
			Fl_Text_Buffer *c1buff = new Fl_Text_Buffer();
			c1_output->buffer(c1buff);

			// add the text to our buffer (to the box)
			c1buff->text(c1_result.c_str());

			// append the values to our total
			blended_one_year_profit += one_year_profit;
			}
			break;
		case 1:
			if(fxrate1 != 0) // they needed to input an exchange rate  
			{
				// cover with currency2 (fxrate1 is between C1 and C2 so we reverse the rate here)
				c1_cost_to_cover = std::abs(currency1size / (1 / fxrate1) ); 

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency1size 
				%final_percent_return %one_year_profit %daily_profit %c1_cost_to_cover;

				// write it to string
				std::string c1_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c1buff = new Fl_Text_Buffer();
				c1_output->buffer(c1buff);

				// add the text to our buffer (to the box)
				c1buff->text(c1_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;

			}
			else
			{
				std::cout << "Error: Currency 1 Cover currency is Currency 2." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		case 2:
			if(fxrate3 != 0) // they needed to input an exchange rate  
			{
				// cover with currency3 (fxrate3 is between C1 and C3)
				c1_cost_to_cover = std::abs(currency1size / (1 / fxrate3) ) ;	

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency1size 
				%final_percent_return %one_year_profit %daily_profit %c1_cost_to_cover;

				// write it to string
				std::string c1_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c1buff = new Fl_Text_Buffer();
				c1_output->buffer(c1buff);

				// add the text to our buffer (to the box)
				c1buff->text(c1_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;
			}
			else
			{
				std::cout << "Error: Currency 1 Cover currency is Currency 3." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		}

	}		
	else // Profit is positive or flat therefore no cost to cover calculation
	{
		boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
		"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency1size %final_percent_return 
		%one_year_profit %daily_profit;

		std::string c1_result = fmt.str();

		/* std::cout << c1_result << std::endl; */

		// This should maybe be global but not sure. It works. 
		// create buffer and assign it to the appropriate text display widget 
		Fl_Text_Buffer *c1buff = new Fl_Text_Buffer();
		c1_output->buffer(c1buff);

		// add the text to our buffer (to the box)
		c1buff->text(c1_result.c_str());

		// append the values to our total
		blended_one_year_profit += one_year_profit;
	}
}

if(currency2size != 0)
{
	if(currency2size > 0)
	{
		total_currency += currency2size;
	}

	/* std::cout << "total currency: " << total_currency << std::endl; */

	// solve for the daily int rate 
	double daily_int_rate = currency2rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (currency2size * currency2rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency2size) * 100;

	// if profit is negative, calculate cost to cover using cover currency input 
	if(one_year_profit < 0)
	{
		// since our profit is negative we have a negative balance so append it to the total debt
		total_debt += currency2size;

		// get selected cover currency from FL_Input
		int cover_currency = C2_currencychoice->value();
		switch (cover_currency) 
		{
		case 0: // Currency1
			if(fxrate1 != 0) // they needed to input an exchange rate  
			{
				// cover with currency1 (fxrate1 is between C1 and C2)
				c2_cost_to_cover = std::abs(currency2size / fxrate1);	

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency2size 
				%final_percent_return %one_year_profit %daily_profit %c2_cost_to_cover;

				// write it to string
				std::string c2_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c2buff = new Fl_Text_Buffer();
				c2_output->buffer(c2buff);

				// add the text to our buffer (to the box)
				c2buff->text(c2_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;

			}
			else
			{
				std::cout << "Error: Currency 2 Cover currency is Currency 1." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		case 1: //Currency2
			{
			// CASE NOT APPLICABLE BECAUSE IT IS THE CURRENT CURRENCY.
			// No exchange rate possible.
			
			c2_cost_to_cover = std::abs(currency2size);

			// Formatting will be same as below 
			boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
			"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency2size %final_percent_return 
			%one_year_profit %daily_profit %c2_cost_to_cover;

			std::string c2_result = fmt.str();

			// create buffer and assign it to the appropriate text display widget 
			Fl_Text_Buffer *c2buff = new Fl_Text_Buffer();
			c2_output->buffer(c2buff);

			// add the text to our buffer (to the box)
			c2buff->text(c2_result.c_str());

			// append the values to our total
			blended_one_year_profit += one_year_profit;
			}
			break;
		case 2:
			if(fxrate2 != 0) // they needed to input an exchange rate  
			{
				// cover with currency3 (fxrate3 is between C2 and C3)
				c2_cost_to_cover = std::abs(currency2size / (1 / fxrate2) );	

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency2size 
				%final_percent_return %one_year_profit %daily_profit %c2_cost_to_cover;

				// write it to string
				std::string c2_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c2buff = new Fl_Text_Buffer();
				c2_output->buffer(c2buff);

				// add the text to our buffer (to the box)
				c2buff->text(c2_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;
			}
			else
			{
				std::cout << "Error: Currency 2 Cover currency is Currency 3." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		}

	}		
	else // Profit is positive or flat therefore no cost to cover calculation
	{
		boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
		"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency2size %final_percent_return 
		%one_year_profit %daily_profit;

		std::string c2_result = fmt.str();

		// create buffer and assign it to the appropriate text display widget 
		Fl_Text_Buffer *c2buff = new Fl_Text_Buffer();

		c2_output->buffer(c2buff);

		// add the text to our buffer (to the box)
		c2buff->text(c2_result.c_str());

		// append the values to our total
		blended_one_year_profit += one_year_profit;
	}

}

if(currency3size != 0)
{
	// only count positive currencies in our total capital 
	if(currency3size > 0)
	{
		total_currency += currency3size;
	}

	// solve for the daily int rate 
	double daily_int_rate = currency3rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (currency3size * currency3rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency3size) * 100;

	// if profit is negative, calculate cost to cover using cover currency input 
	if(one_year_profit < 0)
	{
		// since our profit is negative we have a negative balance so append it to the total debt
		total_debt += currency3size;

		// get selected cover currency from FL_Input
		int cover_currency = C3_currencychoice->value();
		switch (cover_currency) 
		{
		case 0: // Currency1
			if(fxrate3 != 0) // they needed to input an exchange rate  
			{
				// cover with currency1 (fxrate3 is between C1 and C3)
			 	c3_cost_to_cover = std::abs(currency3size / fxrate3);	

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency3size 
				%final_percent_return %one_year_profit %daily_profit %c3_cost_to_cover;

				// write it to string
				std::string c3_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c3buff = new Fl_Text_Buffer();
				c3_output->buffer(c3buff);

				// add the text to our buffer (to the box)
				c3buff->text(c3_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;

			}
			else
			{
				std::cout << "Error: Currency 3 Cover currency is Currency 1." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		case 1: // cover with Currency 2
			if(fxrate2 != 0) // they needed to input an exchange rate  
			{
				// cover with currency2 (fxrate2 is between C2 and C3)
				c3_cost_to_cover = std::abs(currency3size / fxrate2);	

				// format text and set it  
				boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
				"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency3size 
				%final_percent_return %one_year_profit %daily_profit %c3_cost_to_cover;

				// write it to string
				std::string c3_result = fmt.str();

				// create buffer and assign it to the appropriate text display widget 
				Fl_Text_Buffer *c3buff = new Fl_Text_Buffer();
				c3_output->buffer(c3buff);

				// add the text to our buffer (to the box)
				c3buff->text(c3_result.c_str());

				// append the values to our total
				blended_one_year_profit += one_year_profit;
			}
			else
			{
				std::cout << "Error: Currency 3 Cover currency is Currency 2." 
				" User did not enter FX rate between these currencies." << std::endl;
			}
			break;
		case 2:
			{
			// CASE NOT APPLICABLE BECAUSE IT IS THE CURRENT CURRENCY.
			// No exchange rate possible.
			
			c3_cost_to_cover = std::abs(currency3size);

			boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
			"One Year P/L: $%3%\\nDaily P/L: $%4%\\nCost to Cover: $%5%") %currency3size %final_percent_return 
			%one_year_profit %daily_profit %c3_cost_to_cover;

			std::string c3_result = fmt.str();

			// create buffer and assign it to the appropriate text display widget 
			Fl_Text_Buffer *c3buff = new Fl_Text_Buffer();
			c3_output->buffer(c3buff);

			// add the text to our buffer (to the box)
			c3buff->text(c3_result.c_str());

			// append the values to our total
			blended_one_year_profit += one_year_profit;
			}
			break;
		}

	}		
	else // Profit is positive or flat therefore no cost to cover calculation
	{
		boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
		"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency3size %final_percent_return 
		%one_year_profit %daily_profit;

		std::string c3_result = fmt.str();

		// create buffer and assign it to the appropriate text display widget 
		Fl_Text_Buffer *c3buff = new Fl_Text_Buffer();

		c3_output->buffer(c3buff);

		// add the text to our buffer (to the box)
		c3buff->text(c3_result.c_str());

		// append the values to our total
		blended_one_year_profit += one_year_profit;
	}
}

if(tbillsize != 0)
{
	// only count positive currencies 
	if(tbillsize > 0)
	{
		total_currency += tbillsize;
	}

	// solve for the daily int rate 
	double daily_int_rate = tbillrate / 365;

	// set a trade fee to subtract 
	double trade_fee = 7.5;

	// calculate one year rate of return 
	double one_year_profit = (tbillsize * tbillrate) - trade_fee;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / tbillsize) * 100;

	boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
	"One Year P/L: $%3%\\nDaily P/L: $%4%") %tbillsize %final_percent_return %one_year_profit %daily_profit;

	std::string tbill_result = fmt.str();

	// create buffer and assign it to the appropriate text display widget 
	Fl_Text_Buffer *tbill_buffer = new Fl_Text_Buffer();
	tbill_output->buffer(tbill_buffer);

	// add the text to our buffer (to the box)
	tbill_buffer->text(tbill_result.c_str());

	// append the values to our total
	blended_one_year_profit += one_year_profit;
}

// PROCEEDS TEXT OUTPUT
if(currency1proceeds != 0)
{
	// append amount to total currency since we are in possession of the short
	// position proceeds
	total_currency += currency1proceeds;
	
	// solve for the daily int rate 
	double daily_int_rate = currency1proceeds_rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (currency1proceeds * currency1proceeds_rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency1proceeds) * 100;

	boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
	"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency1proceeds %final_percent_return %one_year_profit %daily_profit;

	std::string result = fmt.str();

	// create buffer and assign it to the appropriate text display widget 
	Fl_Text_Buffer *c1_buffer = new Fl_Text_Buffer();
	c1_reinvest_output->buffer(c1_buffer);

	// add the text to our buffer (to the box)
	c1_buffer->text(result.c_str());

	// append the values to our total
	blended_one_year_profit += one_year_profit;
	blended_one_year_profit += one_year_profit;
	std::cout << "1 one year profit: " << one_year_profit << std::endl;
	std::cout << "1 blended one year profit: " << blended_one_year_profit << std::endl;
}

if(currency2proceeds != 0)
{
	// append amount to total currency since we are in possession of the short
	// position proceeds
	total_currency += currency2proceeds;

	// solve for the daily int rate 
	double daily_int_rate = currency2proceeds_rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (currency2proceeds * currency2proceeds_rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency2proceeds) * 100;

	boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
	"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency2proceeds %final_percent_return %one_year_profit %daily_profit;

	std::string result = fmt.str();

	// create buffer and assign it to the appropriate text display widget 
	Fl_Text_Buffer *c2_buffer = new Fl_Text_Buffer();
	c2_reinvest_output->buffer(c2_buffer);

	// add the text to our buffer (to the box)
	c2_buffer->text(result.c_str());

	// append the values to our total
	blended_one_year_profit += one_year_profit;
	std::cout << "2 one year profit: " << one_year_profit << std::endl;
	std::cout << "2 blended one year profit: " << blended_one_year_profit << std::endl;
}

if(currency3proceeds != 0)
{
	// append amount to total currency since we are in possession of the short
	// position proceeds
	total_currency += currency3proceeds;

	// solve for the daily int rate 
	double daily_int_rate = currency3proceeds_rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (currency3proceeds * currency3proceeds_rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / currency3proceeds) * 100;

	boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
	"One Year P/L: $%3%\\nDaily P/L: $%4%") %currency3proceeds %final_percent_return %one_year_profit %daily_profit;

	std::string result = fmt.str();

	// create buffer and assign it to the appropriate text display widget 
	Fl_Text_Buffer *c3_buffer = new Fl_Text_Buffer();
	c3_reinvest_output->buffer(c3_buffer);

	// add the text to our buffer (to the box)
	c3_buffer->text(result.c_str());

	// append the values to our total
	blended_one_year_profit += one_year_profit;
	std::cout << "3 one year profit: " << one_year_profit << std::endl;
	std::cout << "3 blended one year profit: " << blended_one_year_profit << std::endl;
}
if(tbillproceeds != 0)
{
	// Proceeds will always be positive
	
	// append amount to total currency since we are in possession of the short
	// position proceeds
	total_currency += tbillproceeds;

	// solve for the daily int rate 
	double daily_int_rate = tbillproceeds_rate / 365;

	// calculate one year rate of return 
	double one_year_profit = (tbillproceeds * tbillproceeds_rate) ;

	// daily profit 
	double daily_profit = one_year_profit / 365;

	// solve for one year percent rate of return 
	double final_percent_return = (one_year_profit / tbillproceeds) * 100;

	boost::format fmt = boost::format("Position Size: $%1%\\nInterest Rate: %2%%%\\n"
	"One Year P/L: $%3%\\nDaily P/L: $%4%") %tbillproceeds %final_percent_return %one_year_profit %daily_profit;

	std::string result = fmt.str();

	// create buffer and assign it to the appropriate text display widget 
	Fl_Text_Buffer *tbill_buffer = new Fl_Text_Buffer();
	tbill_reinvest_output->buffer(tbill_buffer);

	// add the text to our buffer (to the box)
	tbill_buffer->text(result.c_str());

	// append the values to our total
	blended_one_year_profit += one_year_profit;
	std::cout << "4 one year profit: " << one_year_profit << std::endl;
	std::cout << "4 blended one year profit: " << blended_one_year_profit << std::endl;
}

// LOGIC FOR TOTALS CALCULATIONS 

// solve for blended percent return 
blended_percent_return = (blended_one_year_profit / total_currency) * 100;

// used for solving cost to cover if applicable 
double cost_to_cover = 0;

// used for formatting text to pass into buffer 
std::string result; 

// if any of these currencies are negative we need to format text with cost to cover
if(currency1size < 0 || currency2size < 0 || currency3size < 0)
{
	// simply add up all cost to covers and we will get a total
	double total_cost_to_cover = c1_cost_to_cover + c2_cost_to_cover + c3_cost_to_cover;

	boost::format fmt = boost::format("Total Capital: $%1%\\nTotal Debt: $%2%\\n"
	"Blended Interest Rate: %3%%%\\nOne Year P/L: $%4%\\n"
	"Cost to Cover with FX rate: $%5%") %total_currency %total_debt %blended_percent_return 
	%blended_one_year_profit % total_cost_to_cover ;

	// write to the string
	result = fmt.str();
}
else
{
	// no currencies are negative therefore format without cost to cover 

	boost::format fmt = boost::format("Total Capital: $%1%\\n"
	"Blended Interest Rate: %2%%%\\nOne Year P/L: $%3%\\n") %total_currency 
	%blended_percent_return %blended_one_year_profit ;

	// write to the string
	result = fmt.str();
}

// debug 
/* std::cout << "Total One Year Profit/Loss was: " << blended_one_year_profit */ 
/* << std::endl; */
/* std::cout << "Total return: " << blended_percent_return */ 
/* << "%" << std::endl; */

// create a new buffer 
Fl_Text_Buffer *total_buffer = new Fl_Text_Buffer();

// assign the buffer to a text display widget
blended_output->buffer(total_buffer);

// add the text to our buffer 
total_buffer->text(result.c_str());} {}
}

Function {input_CB(Fl_Widget*w, void* userdata)} {open return_type {static void}
} {
  code {// system(input_currency1size->value());

// Get the user data field from the widget to determine which input was pressed
std::string_view which_input = (const char*)w->user_data();

// debug
/* std::cout << which_input << std::endl; */

// different arrays with valid characters the user can enter 
std::array<char, 12> valid_characters = {'0','1','2','3','4','5'
,'6','7','8','9','-','.'};

std::array<char, 13> rate_valid_characters = {'0','1','2','3','4','5'
,'6','7','8','9','%','-','.'};

std::array<char, 11> proceeds_valid_characters = {'0','1','2','3','4','5'
,'6','7','8','9','.'};

// set to false until proven otherwise
bool invalid_character_found = false;

if(which_input == "currency1size")
{
	// input_currency1size
	std::string_view value = input_currency1size->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < valid_characters.size(); i++)
		{	
			if(value[index] == valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-')
		{
			is_valid_character = false; 
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency1size->value(new_string.c_str());
		}
	}
}
else if(which_input ==  "currency1rate")
{
	// input_currency1rate
	std::string_view value = input_currency1rate->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < rate_valid_characters.size(); i++)
		{	
			if(value[index] == rate_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the input  
		if (index > 0 && value[index] == '-' )
		{
			is_valid_character = false; 
		}

		// catch if they inputted a % sign at any point other than the end of the input
		if(index < value.size() - 1 && value[index] == '%')
		{
			is_valid_character = false; 
		}

		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency1rate->value(new_string.c_str());
		}
	}
}
else if(which_input ==  "currency2size")
{
	// input_currency2size
	std::string_view value = input_currency2size->value();

	/* std::cout << "debug input: " << value << std::endl; */

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < valid_characters.size(); i++)
		{	
			if(value[index] == valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-')
		{
			is_valid_character = false; 
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency2size->value(new_string.c_str());
		}
	}
}
else if(which_input == "currency2rate")
{
	// input_currency2rate
	std::string_view value = input_currency2rate->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < rate_valid_characters.size(); i++)
		{	
			if(value[index] == rate_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-' )
		{
			is_valid_character = false; 
		}
		
		// catch if they inputted a % sign at any point other than the end of the input
		if(index < value.size() - 1 && value[index] == '%')
		{
			is_valid_character = false; 
		}

		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency2rate->value(new_string.c_str());
		}
	}
}
else if(which_input ==  "currency3size")
{
	// input_currency2size
	std::string_view value = input_currency3size->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < valid_characters.size(); i++)
		{	
			if(value[index] == valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-')
		{
			is_valid_character = false; 
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency3size->value(new_string.c_str());
		}
	}
}
else if(which_input == "currency3rate")
{
	// input_currency2rate
	std::string_view value = input_currency3rate->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < rate_valid_characters.size(); i++)
		{	
			if(value[index] == rate_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-' )
		{
			is_valid_character = false; 
		}

		// catch if they inputted a % sign at any point other than the end of the input
		if(index < value.size() - 1 && value[index] == '%')
		{
			is_valid_character = false; 
		}

		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency3rate->value(new_string.c_str());
		}
	}
}

else if(which_input ==  "tbillsize")
{
	// input_currency2size
	std::string_view value = input_tbillsize->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < valid_characters.size(); i++)
		{	
			if(value[index] == valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-')
		{
			is_valid_character = false; 
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_tbillsize->value(new_string.c_str());
		}
	}
}
else if(which_input == "tbillrate")
{
	// input_currency2rate
	std::string_view value = input_tbillrate->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < rate_valid_characters.size(); i++)
		{	
			if(value[index] == rate_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-' )
		{
			is_valid_character = false; 
		}

		// catch if they inputted a % sign at any point other than the end of the input
		if(index < value.size() - 1 && value[index] == '%')
		{
			is_valid_character = false; 
		}

		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_tbillrate->value(new_string.c_str());
		}
	}
}

else if(which_input ==  "currency1proceeds")
{
	// input_currency2size
	std::string_view value = input_currency1proceeds->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < proceeds_valid_characters.size(); i++)
		{	
			if(value[index] == proceeds_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency1proceeds->value(new_string.c_str());
		}
	}

	// PROCEEDS CANNOT EXCEED POSITION THAT GENERATED THE PROCEEDS 
	// obtain input values as doubles 
	double currency1size = std::strtod(input_currency1size->value(), nullptr);
	double currency1proceeds = std::strtod(input_currency1proceeds->value(), nullptr);

	// if user inputted a higher number than what would be allowed 
	if(currency1proceeds > std::abs(currency1size))
	{
		// Only allow two decimal places in the output 
		std::ostringstream ss;
		ss << std::fixed << std::setprecision(2) << std::abs(currency1size);

		// set it to cap at the short currency position size 
		input_currency1proceeds->value(ss.str().c_str());
	}
}
else if(which_input == "currency1proceedsrate")
{
	// input_currency2rate
	std::string_view value = input_currency1proceedsrate->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < rate_valid_characters.size(); i++)
		{	
			if(value[index] == rate_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-' )
		{
			is_valid_character = false; 
		}

		// catch if they inputted a % sign at any point other than the end of the input
		if(index < value.size() - 1 && value[index] == '%')
		{
			is_valid_character = false; 
		}

		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency1proceedsrate->value(new_string.c_str());
		}
	}
}
else if(which_input ==  "currency2proceeds")
{
	// input_currency2size
	std::string_view value = input_currency2proceeds->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < proceeds_valid_characters.size(); i++)
		{	
			if(value[index] == proceeds_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency2proceeds->value(new_string.c_str());
		}
	}

	// PROCEEDS CANNOT EXCEED POSITION THAT GENERATED THE PROCEEDS 
	// obtain input values as doubles 
	double currency2size = std::strtod(input_currency2size->value(), nullptr);
	double currency2proceeds = std::strtod(input_currency2proceeds->value(), nullptr);


	// if user inputted a higher number than what would be allowed 
	if(currency2proceeds > std::abs(currency2size))
	{
		// Only allow two decimal places in the output 
		std::ostringstream ss;
		ss << std::fixed << std::setprecision(2) << std::abs(currency2size);

		// set it to cap at the short currency position size 
		input_currency2proceeds->value(ss.str().c_str());

	}
}
else if(which_input == "currency2proceedsrate")
{
	// input_currency2rate
	std::string_view value = input_currency2proceedsrate->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < rate_valid_characters.size(); i++)
		{	
			if(value[index] == rate_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-' )
		{
			is_valid_character = false; 
		}

		// catch if they inputted a % sign at any point other than the end of the input
		if(index < value.size() - 1 && value[index] == '%')
		{
			is_valid_character = false; 
		}

		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			/* std::cout << "debug new string: " << new_value << std::endl; */
			input_currency2proceedsrate->value(new_string.c_str());
		}
	}
}
else if(which_input ==  "currency3proceeds")
{
	// input_currency2size
	std::string_view value = input_currency3proceeds->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < proceeds_valid_characters.size(); i++)
		{	
			if(value[index] == proceeds_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency3proceeds->value(new_string.c_str());
		}
	}

	// PROCEEDS CANNOT EXCEED POSITION THAT GENERATED THE PROCEEDS 
	// obtain input values as doubles 
	double currency3size = std::strtod(input_currency3size->value(), nullptr);
	double currency3proceeds = std::strtod(input_currency3proceeds->value(), nullptr);

	// if user inputted a higher number than what would be allowed 
	if(currency3proceeds > std::abs(currency3size))
	{
		// Only allow two decimal places in the output 
		std::ostringstream ss;
		ss << std::fixed << std::setprecision(2) << std::abs(currency3size);

		// set it to cap at the short currency position size 
		input_currency3proceeds->value(ss.str().c_str());
	}
}
else if(which_input == "currency3proceedsrate")
{
	// input_currency2rate
	std::string_view value = input_currency3proceedsrate->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < rate_valid_characters.size(); i++)
		{	
			if(value[index] == rate_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-' )
		{
			is_valid_character = false; 
		}

		// catch if they inputted a % sign at any point other than the end of the input
		if(index < value.size() - 1 && value[index] == '%')
		{
			is_valid_character = false; 
		}

		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_currency3proceedsrate->value(new_string.c_str());
		}
	}
}
else if(which_input ==  "tbillproceeds")
{
	// input_currency2size
	std::string_view value = input_tbillproceeds->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < proceeds_valid_characters.size(); i++)
		{	
			if(value[index] == proceeds_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_tbillproceeds->value(new_string.c_str());
		}
	}

	// PROCEEDS CANNOT EXCEED POSITION THAT GENERATED THE PROCEEDS 
	// obtain input values as doubles 
	double tbillsize = std::strtod(input_tbillsize->value(), nullptr);
	double tbillproceeds = std::strtod(input_tbillproceeds->value(), nullptr);

	// if user inputted a higher number than what would be allowed 
	if(tbillproceeds > std::abs(tbillsize))
	{
		// Only allow two decimal places in the output 
		std::ostringstream ss;
		ss << std::fixed << std::setprecision(2) << std::abs(tbillsize);

		// set it to cap at the short currency position size 
		input_tbillproceeds->value(ss.str().c_str());
	}
}
else if(which_input == "tbillproceedsrate")
{
	// input_currency2rate
	std::string_view value = input_tbillproceedsrate->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < rate_valid_characters.size(); i++)
		{	
			if(value[index] == rate_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// catch if they inputted a - sign at any point other than the start of the number  
		if (index > 0 && value[index] == '-' )
		{
			is_valid_character = false; 
		}

		// catch if they inputted a % sign at any point other than the end of the input
		if(index < value.size() - 1 && value[index] == '%')
		{
			is_valid_character = false; 
		}

		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			// create a new string that removes the invalid character from the string
			std::string_view prefix = value.substr(0, index);
			std::string_view suffix = value.substr(index + 1);

			// Combine the substrings 
			std::string new_string = std::string(prefix) + std::string(suffix);

			/* std::cout << "Original String: " << value << std::endl; */
			/* std::cout << "String Without Character at Index " << index << ": " */
			/* << new_string << std::endl; */

			input_tbillproceedsrate->value(new_string.c_str());
		}
	}
}
else if(which_input ==  "fxrate1")
{
	// input_currency2size
	std::string_view value = input_fxrate1->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < proceeds_valid_characters.size(); i++)
		{	
			if(value[index] == proceeds_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			std::string_view new_value = value.substr(0, value.size() -1);

			/* std::cout << "debug new string: " << new_value << std::endl; */
			input_fxrate1->value(std::string(new_value).c_str());
		}
	}
}
else if(which_input ==  "fxrate2")
{
	// input_currency2size
	std::string_view value = input_fxrate2->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < proceeds_valid_characters.size(); i++)
		{	
			if(value[index] == proceeds_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			std::string_view new_value = value.substr(0, value.size() -1);

			/* std::cout << "debug new string: " << new_value << std::endl; */
			input_fxrate2->value(std::string(new_value).c_str());
		}
	}
}
else if(which_input ==  "fxrate3")
{
	// input_currency2size
	std::string_view value = input_fxrate3->value();

	// for each character in the string
	for(int index = 0; index < value.size(); index++)
	{
		// compare current character of the input string against list of valid
		// characters to see if the character is valid.
		bool is_valid_character = false;

		// iterate over valid characters array and remember if we got a match
		for(int i = 0; i < proceeds_valid_characters.size(); i++)
		{	
			if(value[index] == proceeds_valid_characters[i])
			{
				// character is valid
				is_valid_character = true;
				break;
			}
		}
		// if we went through the nested for loop and no valid match was found,
		// it means we have found an invalid character at the current index. 
		if(is_valid_character == false)
		{
			std::string_view new_value = value.substr(0, value.size() -1);

			/* std::cout << "debug new string: " << new_value << std::endl; */
			input_fxrate3->value(std::string(new_value).c_str());
		}
	}
}} {selected
  }
}

Function {WinQuit_CB(Fl_Widget*, void*)} {open return_type {static void}
} {
  code {/* printf("Window Quit CALLBACK!\\n"); */
exit(0);} {}
}

Function {} {open
} {
  Fl_Window window {
    label {Currency Spread Calculator - FLTK v1.4}
    callback WinQuit_CB open
    xywh {93 346 586 496} type Double align 80 hide resizable non_modal
  } {
    Fl_Group {} {open
      xywh {4 6 578 482} box ENGRAVED_BOX
    } {
      Fl_Box {} {
        label label
        xywh {4 34 573 61} box OXY_BUTTON_DOWN_BOX labeltype NO_LABEL
      }
      Fl_Box {} {
        label label
        xywh {4 94 573 58} box OXY_BUTTON_DOWN_BOX color 28 labeltype NO_LABEL
      }
      Fl_Box {} {
        label label
        xywh {4 178 576 61} box OXY_BUTTON_DOWN_BOX labeltype NO_LABEL
      }
      Fl_Box {} {
        label label
        xywh {4 238 576 58} box OXY_BUTTON_DOWN_BOX color 28 labeltype NO_LABEL
      }
      Fl_Flex left_flex {open
        xywh {175 35 101 117}
      } {
        Fl_Input input_currency1size {
          label {Currency 1 position size:}
          user_data {"currency1size"}
          callback input_CB
          xywh {175 35 101 30} when 1
        }
        Fl_Input input_currency1rate {
          label {Currency 1 interest rate:}
          user_data {"currency1rate"}
          callback input_CB
          xywh {175 65 101 29} when 1
        }
        Fl_Input input_currency3size {
          label {Currency 3 position size:}
          user_data {"currency3size"}
          callback input_CB
          xywh {175 94 101 29} when 1
        }
        Fl_Input input_currency3rate {
          label {Currency 3 interest rate:}
          user_data {"currency3rate"}
          callback input_CB
          xywh {175 123 101 29} when 1
        }
      }
      Fl_Return_Button submit_button {
        label Calculate
        user_data {"calculate"}
        callback Calculate_CB
        tooltip {Press this once values are entered} xywh {433 439 133 37} box OXY_UP_BOX color 16 when 12
      }
      Fl_Button clear_button {
        label {Clear All}
        callback clear_CB
        xywh {54 443 110 29} box OXY_UP_BOX color 31 labelcolor 55
      }
      Fl_Button save_button {
        label Save
        callback save_CB
        xywh {303 439 120 37} box OXY_UP_BOX
      }
      Fl_Button load_button {
        label Load
        callback load_CB
        xywh {174 439 120 37} box OXY_UP_BOX
      }
      Fl_Flex right_flex {open
        xywh {450 35 131 118}
      } {
        Fl_Input input_currency2size {
          label {Currency 2 position size:}
          user_data {"currency2size"}
          callback input_CB
          xywh {450 35 131 30} when 1
        }
        Fl_Input input_currency2rate {
          label {Currency 2 interest rate:}
          user_data {"currency2rate"}
          callback input_CB
          xywh {450 65 131 30} when 1
        }
        Fl_Input input_tbillsize {
          label {Long T-Bill position size:}
          user_data {"tbillsize"}
          callback input_CB
          xywh {450 95 131 29} when 1
        }
        Fl_Input input_tbillrate {
          label {T-Bill interest rate:}
          user_data {"tbillrate"}
          callback input_CB
          xywh {450 124 131 29} when 1
        }
      }
      Fl_Flex middle_left_flex {open
        xywh {176 179 101 117}
      } {
        Fl_Input input_currency1proceeds {
          label {Currency 1 proceeds:}
          user_data {"currency1proceeds"}
          callback input_CB
          xywh {176 179 101 30} when 1
        }
        Fl_Input input_currency1proceedsrate {
          label {Proceeds Rate of Return:}
          user_data {"currency1proceedsrate"}
          callback input_CB
          xywh {176 209 101 29} when 1
        }
        Fl_Input input_currency3proceeds {
          label {Currency 3 proceeds:}
          user_data {"currency3proceeds"}
          callback input_CB
          xywh {176 238 101 29} when 1
        }
        Fl_Input input_currency3proceedsrate {
          label {Proceeds Rate of Return:}
          user_data {"currency3proceedsrate"}
          callback input_CB
          xywh {176 267 101 29} when 1
        }
      }
      Fl_Flex middle_right_flex {open
        xywh {450 179 131 118}
      } {
        Fl_Input input_currency2proceeds {
          label {Currency 2 proceeds:}
          user_data {"currency2proceeds"}
          callback input_CB
          xywh {450 179 131 30} when 1
        }
        Fl_Input input_currency2proceedsrate {
          label {Proceeds Rate of Return:}
          user_data {"currency2proceedsrate"}
          callback input_CB
          xywh {450 209 131 30} when 1
        }
        Fl_Input input_tbillproceeds {
          label {Short T-Bill Proceeds:}
          user_data {"tbillproceeds"}
          callback input_CB
          xywh {450 239 131 29} when 1
        }
        Fl_Input input_tbillproceedsrate {
          label {Proceeds Rate of Return:}
          user_data {"tbillproceedsrate"}
          callback input_CB
          xywh {450 268 131 29} when 1
        }
      }
      Fl_Box {} {
        label label
        xywh {29 323 480 32} box THIN_UP_FRAME color 40 selection_color 78 labeltype NO_LABEL labelsize 15
      }
      Fl_Input input_fxrate1 {
        label {Projected FX Rate Between Currency 1 && 2:}
        user_data {"fxrate1"}
        callback input_CB
        xywh {336 328 99 23} box GTK_THIN_DOWN_BOX color 96 selection_color 50 labelsize 15 labelcolor 32 when 1 textcolor 55
      }
      Fl_Button invert_rate1 {
        label Invert
        user_data {"invert1"}
        callback invert_CB
        xywh {440 328 64 22}
      }
      Fl_Box {} {
        label label
        xywh {29 357 480 32} box THIN_UP_FRAME color 40 selection_color 78 labeltype NO_LABEL labelsize 15
      }
      Fl_Input input_fxrate2 {
        label {Projected FX Rate Between Currency 2 && 3:}
        user_data {"fxrate2"}
        callback input_CB
        xywh {336 362 99 23} box GTK_THIN_DOWN_BOX color 96 selection_color 50 labelsize 15 labelcolor 32 when 1 textcolor 55
      }
      Fl_Button invert_rate2 {
        label Invert
        user_data {"invert2"}
        callback invert_CB
        xywh {440 362 64 22}
      }
      Fl_Box {} {
        label label
        xywh {29 391 480 32} box THIN_UP_FRAME color 40 selection_color 78 labeltype NO_LABEL labelsize 15
      }
      Fl_Input input_fxrate3 {
        label {Projected FX Rate Between Currency 1 && 3:}
        user_data {"fxrate3"}
        callback input_CB
        xywh {336 396 99 23} box GTK_THIN_DOWN_BOX color 96 selection_color 50 labelsize 15 labelcolor 32 when 1 textcolor 55
      }
      Fl_Button invert_rate3 {
        label Invert
        user_data {"invert3"}
        callback invert_CB
        xywh {440 396 64 22}
      }
      Fl_Grid header_grid1 {open
        xywh {5 7 572 27} box NO_BOX align 17 deactivate
        dimensions {1 3}
      } {
        Fl_Output account_positions_header {
          xywh {189 7 204 27} box NO_BOX color 49 selection_color 49 labeltype NO_LABEL labelsize 15 align 8
          code0 {account_positions_header->value("Account Positions (Long/Short)");}
          parent_properties {
            location {0 1}
            minsize {21 20}
          }
        }
      }
      Fl_Grid header_grid2 {open
        xywh {5 152 572 27} box NO_BOX align 17 deactivate
        dimensions {1 3}
        colwidths { 12 0 0 }
      } {
        Fl_Output proceeds_positions_header {
          xywh {197 152 200 27} box NO_BOX color 49 selection_color 49 labeltype NO_LABEL labelsize 15 align 8
          code0 {proceeds_positions_header->value("Proceeds from Short Positions (Long Only)");}
          parent_properties {
            location {0 1}
          }
        }
      }
      Fl_Grid header_grid4 {open
        xywh {7 296 572 27} box NO_BOX
        dimensions {1 3}
        colwidths { 65 0 0 }
      } {
        Fl_Output settings_header {
          xywh {235 296 182 27} box NO_BOX color 32 selection_color 32 labeltype NO_LABEL labelsize 15 labelcolor 32 align 8 textcolor 32
          code0 {settings_header->value("General Settings");}
          parent_properties {
            location {0 1}
          }
        }
      }
    }
  }
  code {// POPULATE SAVED INPUT VALUES FROM DATABASE 

// open (ALREADY IN ABOVE CODE)
sqlite3_open(dbPath, &db);

const char* checkTableExistsQuery = "SELECT name FROM sqlite_master WHERE type='table' AND name='MAINWINDOW_INPUTS';";

if (sqlite3_prepare_v2(db, checkTableExistsQuery, -1, &stmt, nullptr) == SQLITE_OK) 
{
	if (sqlite3_step(stmt) == SQLITE_ROW) 
	{
		/* std::cout << "Table exists!" << std::endl; */

		// FINALIZE before going to next prepared statement 
		int finalize = sqlite3_finalize(stmt);
		if(finalize != SQLITE_OK) 
		{
			std::cout<< finalize << std::endl; 
		}
		/* else */
		/* { */
			/* std::cout << " SQL Statement Finalized..." << std::endl; */
		/* } */

		// prepare statement to obtain values from the DB 
		sqlite3_prepare_v2(db, "SELECT * from MAINWINDOW_INPUTS LIMIT 1", -1, &stmt, 0); 

		while(sqlite3_step(stmt) != SQLITE_DONE) 
		{ 
			const unsigned char* currency1size = sqlite3_column_text(stmt, 1);	
			input_currency1size->value((const char*)currency1size);

			const unsigned char* currency1rate = sqlite3_column_text(stmt, 2);	
			input_currency1rate->value((const char*)currency1rate);

			const unsigned char* currency2size = sqlite3_column_text(stmt, 3);	
			input_currency2size->value((const char*)currency2size);

			const unsigned char* currency2rate = sqlite3_column_text(stmt, 4);	
			input_currency2rate->value((const char*)currency2rate);

			const unsigned char* currency3size = sqlite3_column_text(stmt, 5);	
			input_currency3size->value((const char*)currency3size);

			const unsigned char* currency3rate = sqlite3_column_text(stmt, 6);	
			input_currency3rate->value((const char*)currency3rate);

			const unsigned char* tbillsize = sqlite3_column_text(stmt, 7);	
			input_tbillsize->value((const char*)tbillsize);

			const unsigned char* tbillrate = sqlite3_column_text(stmt, 8);	
			input_tbillrate->value((const char*)tbillrate);

			const unsigned char* currency1proceeds_size = sqlite3_column_text(stmt, 9);	
			input_currency1proceeds->value((const char*)currency1proceeds_size);

			const unsigned char* currency1proceeds_rate = sqlite3_column_text(stmt, 10);	
			input_currency1proceedsrate->value((const char*)currency1proceeds_rate);

			const unsigned char* currency2proceeds_size = sqlite3_column_text(stmt, 11);	
			input_currency2proceeds->value((const char*)currency2proceeds_size);

			const unsigned char* currency2proceeds_rate = sqlite3_column_text(stmt, 12);	
			input_currency2proceedsrate->value((const char*)currency2proceeds_rate);

			const unsigned char* currency3proceeds_size = sqlite3_column_text(stmt, 13);	
			input_currency3proceeds->value((const char*)currency3proceeds_size);

			const unsigned char* currency3proceeds_rate = sqlite3_column_text(stmt, 14);	
			input_currency3proceedsrate->value((const char*)currency3proceeds_rate);

			const unsigned char* tbillproceeds = sqlite3_column_text(stmt, 15);	
			input_tbillproceeds->value((const char*)tbillproceeds);

			const unsigned char* tbillproceeds_rate = sqlite3_column_text(stmt, 16);	
			input_tbillproceedsrate->value((const char*)tbillproceeds_rate);

			const unsigned char* fxrate1 = sqlite3_column_text(stmt, 17);	
			input_fxrate1->value((const char*)fxrate1);

			const unsigned char* fxrate2 = sqlite3_column_text(stmt, 18);	
			input_fxrate2->value((const char*)fxrate2);

			const unsigned char* fxrate3 = sqlite3_column_text(stmt, 19);	
			input_fxrate3->value((const char*)fxrate3);
		}

		// The application must finalize every prepared statement in order to avoid resource leaks.
		// // finalize second statement 
		finalize = sqlite3_finalize(stmt);
		if(finalize != SQLITE_OK) 
		{
			std::cout<< finalize << std::endl; 
		}
		/* else */
		/* { */
			/* std::cout << " SQL Statement Finalized..." << std::endl; */
		/* } */
	} 
	/* else */ 
	/* { */
	/* 	std::cout << "Table does not exist. Gracefully doing nothing..." << std::endl; */
	/* } */
} 
else 
{
	std::cerr << "Error preparing SQL statement" << std::endl;
}

sqlite3_close(db); // close the database} {}
  code {// ICON CODE 
const char *name = (argc > 1) ? argv[1] : "logo.png";
if (argc>1) argc = 1; // BAD HACK !

Fl_PNG_Image *img = new Fl_PNG_Image(name); // load image
if (img->w() == 0 || img->h() == 0) {
fl_message("Can't open icon file '%s'",name);
exit(1);
}

// set icon and xclass

window->icon(img); // set window icon

const char *xc = strrchr(name,'/'); // find file name part
if (!xc) xc = name; // no directory part
window->xclass(xc); // set xclass for grouping} {}
}
